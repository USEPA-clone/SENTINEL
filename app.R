##########################################################

#                 S  E  N  T  I  N  E  L                #
#            SENsor INtelligent Emissions Locator       #

##########################################################

# M.K. MacDonald
# macdonald.megan@epa.gov

# Rev. 1.1: February 6 2023

# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.

##########################################################
options(install.packages.check.source = "no")

require(shiny)  
require(data.table)  
require(stringr)  
require(leaflet)  
require(shinydashboard)  
require(shinycssloaders)
require(DT)  
require(openair)
library(lattice)
require(plotly)  
require(tidyverse)
require(lubridate)  
require(ggpubr)

require(tinytex)
# tinytex::install_tinytex()  ## make sure this is run the first time running the app
require(knitr)
require(kableExtra)
library(tidyverse)
library(rmarkdown)

library(htmltools)
require(devtools)  
#install_github("davidcarslaw/openairmaps")  
require(openairmaps)  


require(quantreg)  
require(splines2)  
require(splines)  

source("getBaseline.R")

# code version
version <- "1.0"
##########################################################

########################################################### app starts here:




ui <- dashboardPage( ###################################################### build sidebar
  skin = "black", # choose panel color for app
  dashboardHeader(title = "SENTINEL"),
  dashboardSidebar(
    sidebarMenu(
      tags$a(img(src="ngemlogo.png", width = 125,
                 style="display: block; margin-left: auto; margin-right: auto;"),
             href="https://www.epa.gov/air-research/next-generation-emission-measurement-ngem-research-fugitive-air-pollution"),
      menuItem(
        "Data Upload",
        tabName = "dataupload",
        icon = icon("fas fa-turn-up")
      ),
      menuItem( # make side bar menu items
        "Dashboard",
        tabName = "home",
        icon = icon("fas fa-house")
      ),
      menuItem( # make side bar menu items
        "Data Table",
        tabName = "DataTable",
        icon = icon("fas fa-list")
      ),
      menuItem(
        "Calibrations",
        tabName = "calibrations",
        icon = icon("fas fa-wrench"),
        menuSubItem('Single Node',
                    tabName = 'singlenode',
                    icon = icon('fas fa-chevron-right')),
        menuSubItem('Multiple Nodes',
                    tabName = 'multinode',
                    icon = icon('fas fa-chevron-right'))
      ),
      menuItem(
        "About",
        tabName = "about",
        icon = icon("fas fa-heart")
      )
    )
  ),
  dashboardBody( ################################################## build main page of app
    tabItems(
      tabItem(tabName = "dataupload", ############################ build DATA UPLOAD page
              h2("Data Upload"),
              br(),
              h4("File must have the following naming convention: "),
              div("SPOD_Data_Export_1181_2022-07-10.csv ", style = "color:blue; text-align:center; font-size:20px;"),
              h4("Where SPOD_Data_Export_ is automatically generated by Sensit Connect, 1181 is the Sensor ID, and 2022-07-10 is the date of the data collection. These values will be parsed by the processing code, so it is important to name the files in this way exactly."),
              br(),
              fileInput("files",
                        label = "Upload downloaded Sensit Connect file(s) here",
                        multiple = TRUE),
              br(),
              DTOutput(outputId = "contents5")%>% withSpinner(color = "#0dc5c1")
      ),
      
      tabItem(tabName = "home", ################################## build DASHBOARD page
              fluidRow( box(uiOutput("spodselect")),
                        box(h4("Output a pdf of this pdashboard:"),
                            br(),
                            downloadButton("report_button", "Generate report"))
              ),
              fluidRow(
                tabBox(
                  title = "Signal Map",side = "right",  ### Signal Map Box
                  tabPanel("Graph",
                           fluidRow(leafletOutput("polarmap", height = "550px") %>% withSpinner(color = "#0dc5c1"),  height = "550px"),
                           textOutput("latlongtext"),
                  ),
                  tabPanel("Controls", "Controls",
                           sliderInput(
                             "windfilterInput",
                             label = h4("Wind Speed Filter:"),
                             min = 0,
                             max = 20,
                             value = 10
                           ),
                           selectInput(
                             "statselect",
                             label = h4("Select Stat:"),
                             choices = list(
                               "Median" = "median",
                               "Weighted Mean" = "weighted.mean",
                               "Maximum" = "max"
                             ),
                             selected = "median"
                           ),height = "500px"
                  ), height = "500px"
                ),
                tabBox(
                  title = "SDI plots",side = "right",   ### SDI plots box
                  tabPanel("SDI Plots",
                           selectInput(
                             "statselectSDI",
                             label = h4("Select Stat:"),
                             choices = list(
                               "Median" = "median",
                               "Weighted Mean" = "weighted.mean",
                               "Mean" = "mean",
                               "Maximum" = "max"
                             ),
                             selected = "median"
                           ),
                           fluidRow(
                             box(plotOutput("FREQ") %>% withSpinner(color="#0dc5c1"),
                                 height = "450px"),
                             box(plotOutput("SDI")%>% withSpinner(color="#0dc5c1"),
                                 height = "450px")
                             
                           ), height = "470px"
                  ),
                  tabPanel("Wind Rose",
                           fluidRow(
                             box(plotOutput("WR") %>% withSpinner(color = "#0dc5c1")),
                             height = "450px"), height = "470px")),
                
                height = "500px"
              ),
              fluidRow( ### Time Series plots box
                tabBox(
                  title = "Time Series",side = "right",
                  tabPanel("Baseline Fit", "Baseline Fit: Raw signal trace (5 minute values) plotted in black with baseline fit (df = 4) plotted in red",
                           plotlyOutput("BCplot")),
                  tabPanel("Wind Direction", "Wind Direction: Baseline corrected signal trace plotted in black with wind direction plotted in orange (5 minute values)",
                           plotlyOutput("windplot")),
                  tabPanel("Can Triggers", "Canister Triggers: Baseline corrected signal trace plotted in black with canister triggers plotted as points, if collected during this time frame",
                           plotlyOutput("canplot")), width = 12
                ), width = 12
              ),
              
      ),
      tabItem( ##################################################### build DATA TABLE page
        tabName = "DataTable", # make data table page
        h4("Table Results"),
        br(),
        downloadButton('Download',"Download .CSV data"),
        br(),
        DTOutput(outputId = "datatab", width = 1000)
      ),
      
      tabItem(##################################################### build SINGLE CALIBRATION page
        tabName = "singlenode",
        h2("Calibration QA Table for 1 Unit"),
        br(),
        h4("File must have the following naming convention: "),
        div("SPOD_Data_Export_1181_2022-07-10.csv ", style = "color:blue; text-align:center; font-size:20px;"),
        h4("Where SPOD_Data_Export_ is automatically generated by Sensit Connect, 1181 is the Sensor ID, and 2022-07-10 is the date of the data collection. These values will be parsed by the processing code, so it is important to name the files in this way exactly."),
        br(),
        fileInput("file1",
                  label= h4("Upload 10 second raw .CSV file here"),
                  multiple = FALSE),
        br(),
        uiOutput("singlenodestarttime"),
        uiOutput("singlenodeendtime"),
        br(),
        radioButtons("durationInput", h4("Select length of QA frame:"),
                     choices = c("1 min" = 60, "1 hour" = 3600),
                     selected = "1 min"),
        radioButtons("freqfile", h4("Select Frequency of sensor values:"),
                     choices = c("10 sec" = 10,
                                 "30 sec" = 30,
                                 "1 min" = 60),
                     selected = "10 sec"),
        downloadButton("singlenodereport", "Generate pdf report"),
        box(plotOutput("draw_caltab"), width = 12)),
      tabItem(tabName = "multinode", ######################### build MULTI CALIBRATION page
              h2("Calibration QA Table for 2 Collocated Units"),
              br(),
              br(),
              h4("File must have the following naming convention: "),
              div("SPOD_Data_Export_1181_2022-07-10.csv ", style = "color:blue; text-align:center; font-size:20px;"),
              h4("Where SPOD_Data_Export_ is automatically generated by Sensit Connect, 1181 is the Sensor ID, and 2022-07-10 is the date of the data collection. These values will be parsed by the processing code, so it is important to name the files in this way exactly."),
              br(),
              fileInput("file1multi",
                        label= h4("Upload 10 second processed .CSV file here"),
                        multiple = FALSE),
              fileInput("file2multi",
                        label= h4("Upload 10 second processed .CSV file here"),
                        multiple = FALSE),
              br(),
              uiOutput("multinodestarttime"),
              uiOutput("multinodeendtime"),
              br(),
              radioButtons("durationInput2", h4("Select length of QA frame:"),
                           choices = c("1 min" = 60, "1 hour" = 3600),
                           selected = "1 min"),
              radioButtons("freqfile2", h4("Select Frequency of sensor values:"),
                           choices = c("10 sec" = 10,
                                       "30 sec" = 30,
                                       "1 min" = 60),
                           selected = "10 sec"),
              downloadButton("multinodereport", "Generate pdf report"),
              box(plotOutput("draw_subcaltab"), width = 12)
      ),
      tabItem( ####################################################### build ABOUT page
        tabName = "about",
        fluidRow( width = 12,
          box( width = 12,
          br(),
          h4("Sensor Intelligent Emissions Locator (SENTINEL) is designed to compile, visualize, and analyze fenceline sensor data for users. The QA table functionality of this software is further explained in the Sensit SPod SOP (See link below). 
             We awknowledge contributions from past and present contributors to this software: Halley Brantley, Yadong Xu, Wei Tang, and Gustavo Quieroz."),
          br()
          )
        ),
        fluidRow(
          box( width = 6,
               h3("Version 1.0 (February 2023)"),
               br(),
               h4("Contact:"),
               h4("macdonald.megan@epa.gov"),
               br(),
               br()
              ),  
          box(width = 6,
            actionButton("pdf", "SENTINEL User Guide", class = "btn-lg",),
            br(),
            br(),
            actionButton("SOP", "Sensit SPod SOP", class = "btn-lg",),
            br(),
            br(),
            actionButton(inputId='ab1', label="NGEM Website",class = "btn-lg",
                         onclick ="window.open('https://www.epa.gov/air-research/next-generation-emission-measurement-ngem-research-fugitive-air-pollution', '_blank')")
          )
        ),

        fluidRow(
          box(width = 4,
              h3("Technical Info:"),
              actionButton(inputId='ab1', label="Reading SDI Plots",class = "btn-success", class = "btn-lg",
                           onclick ="window.open('https://bookdown.org/david_carslaw/openair/', '_blank')"),
              br(),
              br(),
              actionButton(inputId='ab1', label="Sensit SPods Manual",class = "btn-success", class = "btn-lg",
                           onclick ="window.open('https://gasleaksensors.com/products/sensit-spod-voc-emissions-air-pollutant-monitor/', '_blank')"),
              br(),
              br(),
              actionButton(inputId='ab1', label="Sensit Connect",class = "btn-success", class = "btn-lg",
                           onclick ="window.open('https://sensitconnect.net/sessions/signin?return=%2Fdashboard', '_blank')"),), 
          box(width = 4,
              h3("Webinars:"),
              actionButton(inputId='ab1', label="Seminar: NGEM Advancements ",class = "btn-info", class = "btn-lg",
                           onclick ="window.open('https://www.youtube.com/watch?v=jUTQrVVTYNg', '_blank')"),
              br(),
              br(),
              actionButton(inputId='ab1', label="Fenceline Sensors Comparison Study",class = "btn-info", class = "btn-lg",
                           onclick ="window.open('https://www.youtube.com/watch?v=ACFm8-WhMRU', '_blank')"),
              br(),
              br(),
              actionButton(inputId='ab1', label="SPods Tools and Resources Webinar",class = "btn-info", class = "btn-lg",
                           onclick ="window.open('https://www.epa.gov/research-states/sensor-pods-volatile-organic-compound-fenceline-monitoring-and-data-analysis', '_blank')")), 
          box(width = 4,
              h3("Articles:"),
              actionButton(inputId='ab1', label="NGEM Science Matters Article",class = "btn-primary", class = "btn-lg",
                           onclick ="window.open('https://www.epa.gov/sciencematters/epa-researchers-develop-new-air-monitoring-technology-understand-leaks-and-irregular', '_blank')"),
              br(),
              br(),
              actionButton(inputId='ab1', label="2019 Rubbertwon Study",class = "btn-primary", class = "btn-lg",
                           onclick ="window.open('https://www.mdpi.com/1660-4601/16/11/2041', '_blank')"),
              br(),
              br(),
              actionButton(inputId='ab1', label="2022 Rubbertwon Study",class = "btn-primary", class = "btn-lg",
                           onclick ="window.open('https://www.mdpi.com/1424-8220/22/9/3480', '_blank')"))
        )
        
      )
    )
  )
)







server <- function(input, output, session) {
  options(shiny.maxRequestSize=50*1024^2) # extend file allowance
  ######################################################### Data input multiple csv files
  spod_all_5min <- reactive({
    req(input$files)
    inFile <- input$files
    if (is.null(inFile)){
      return(NULL)
    } else {
      numfiles = nrow(inFile)
      filelist = list()
      for (i in 1:numfiles)
      {
        Data_sensit <- fread(input$files[[i, 'datapath']], select = c(2:21), skip = 2, fill = TRUE)
        Data_sensit$time <- as.POSIXct(Data_sensit$`Local Date Time`,format = "%d-%b-%Y %H:%M:%S", tz = "America/New_York")
        # Complete quick Auto QA scan
        Data_sensit$QA <- 0 #set each of these to a code in QA col
        # check file size? test for data output rate (flag if not 10 sec or 30 sec - make switch in app for this )
        # check for high humidity or high humidity swings
        # check for high temp swings
        # check for missing data
        Data_sensit$QA <- ifelse(is.na(Data_sensit$pid1_PPB_Calc),1,0 )
        # check for very negative PID
        Data_sensit$QA <- ifelse(Data_sensit$pid1_PPB_Calc < -10,2,0 )
        # check for very high PID
        Data_sensit$QA <- ifelse(Data_sensit$pid1_PPB_Calc > 1500,3,0 )
        # check for repeated wind/PID vals
        Data_sensit$QA <- ifelse(rep(rle(Data_sensit$ws_speed)$lengths,
                                     times = rle(Data_sensit$ws_speed)$lengths) * sign(Data_sensit$ws_speed) > 10, 5, 0 )
        Data_sensit$QA <- ifelse(rep(rle(Data_sensit$ws_direction)$lengths,
                                     times = rle(Data_sensit$ws_direction)$lengths) * sign(Data_sensit$ws_direction) > 10, 5, 0 )
        Data_sensit$QA <- ifelse(rep(rle(Data_sensit$pid1_PPB_Calc)$lengths,
                                     times = rle(Data_sensit$pid1_PPB_Calc)$lengths) * sign(Data_sensit$ws_direction) > 10, 5, 0 )
        # check for illogical wind vals
        Data_sensit$QA <- ifelse(Data_sensit$ws_speed > 12,4,0 )
        Data_sensit$QA <- ifelse(Data_sensit$ws_direction > 360 | Data_sensit$ws_direction < 0,4,0 )
        #remove baseline #######
        Data_sensit$bc_pid <- (Data_sensit$pid1_PPB_Calc - getBaseline(Data_sensit$pid1_PPB_Calc, Data_sensit$time, df = 4))
        # Calc u wind and v wind
        Data_sensit$u <- Data_sensit$ws_speed * sin(2 * pi * Data_sensit$ws_direction/360)
        Data_sensit$v <- Data_sensit$ws_speed * cos(2 * pi * Data_sensit$ws_direction/360)
        # Check for lat and long
        if(!'lat' %in% names(Data_sensit)) Data_sensit <- Data_sensit %>% add_column(lat = NA)
        if(!'long' %in% names(Data_sensit)) Data_sensit <- Data_sensit %>% add_column(long = NA)
        # roll up to 5 min
        timeBase <- "5 min"
        timeBreaks <- seq(round(min(Data_sensit$time, na.rm = T), "hour"),
                          round(max(Data_sensit$time, na.rm = T), "hour"), timeBase)
        Data_sensit$time <- cut(Data_sensit$time, timeBreaks)
        
        Data_sensit_5 <- Data_sensit %>%
          dplyr::group_by(time) %>%
          dplyr::summarize(
            bc.pid.ppb = mean(bc_pid),
            pid.sd = sd(bc_pid, na.rm = TRUE),
            rawPID_ppb = mean(pid1_PPB_Calc),
            temp = mean(temp),
            rh = mean(rh_Humd),
            pressure = mean(pressure_mbar),
            u.wind = mean(u),
            v.wind = mean(v),
            s1temp = mean(tc_temp),
            s1heat = mean(tc_heatOutput),
            set = mean(tc_setPoint),
            bat_volt = mean(batt_voltage),
            chg.current = mean(chrg_current),
            opp.current = mean(run_current),
            trigportstat =  paste(unique(trig.canister_status), collapse = ', '),
            trigactivestat = paste(unique(trig.trig_value), collapse = ', '),
            trigactiveflag = paste(unique(trig.trig_activeFlag), collapse = ', '),
            trigsampleflag = paste(unique(trig.trig_eventFlag), collapse = ', '),
            lat = unique(lat, na.rm = TRUE),
            long = unique(long, na.rm = TRUE),
            QA = paste(unique(QA), collapse = ', ')
          )
        # calc MDL
        Data_sensit_5$MDL <- 3 * median(Data_sensit_5$pid.sd)
        #revert wind back to ws and wd
        Data_sensit_5$wd <- atan2(-Data_sensit_5$u.wind, -Data_sensit_5$v.wind)*180/pi + 180
        Data_sensit_5$ws <- sqrt(Data_sensit_5$u.wind^2 + Data_sensit_5$v.wind^2)
        # Identify node and append
        a <- input$files$name[[i]]
        node <- str_match(a, "Export_\\s*(.*?)\\s*_20")
        ID <- node[,2]
        Data_sensit_5$SN <- paste0("SPOD", ID)
        # Roll up data
        filelist[[i]] <- Data_sensit_5
      }
      do.call(rbind, filelist)
    }
  })
  
  ############################################################################## DATA INPUT output table
  output$contents5 <-  DT::renderDataTable({
    req(spod_all_5min())
    x <- as.data.frame(spod_all_5min())
    y <- x %>%
      # mutate(Serial.number = factor(SN)) %>%
      group_by(SN) %>%
      dplyr::summarize(Count = n(),
                       lat = unique(lat),
                       long = unique(long))
    DT::datatable(y)
  })
  ############################################################################## DASHBOARD outputs
  ######################################################## SPOD selector
  output$spodselect <- renderUI({
    choice <-  unique(spod_all_5min()$SN)
    selectInput("spodselect",h4("Select SPOD unit to display:"), choices = choice, selected = choice[1])
  })
  ######################################################## Date range selector
 ## megan add this.....
  ######################################################## Leaflet polar map
  output$polarmap <- renderLeaflet({
    req(input$spodselect)
    req(input$statselect)
    spodinput <- input$spodselect
    statinput <- input$statselect
    req(spod_all_5min())
    spod_all_5 <- as.data.frame(spod_all_5min())
    spod_all_5_1 <- subset(spod_all_5,
                           spod_all_5$SN == input$spodselect &
                             spod_all_5$ws <= input$windfilterInput &
                             spod_all_5$QA == 0)
    
    output$latlongtext <- renderText({ "Note: If no lat/long data is detected, basemap will not be displayed"})
    
    polarMap(spod_all_5_1,
             latitude = 'lat',
             longitude = 'long',
             pollutant = 'bc.pid.ppb',
             statistic = statinput,
             provider = "Esri.WorldImagery",
             cols = "jet",
             key = TRUE,
             iconWidth = 350, iconHeight = 350,
             fig.width = 5, fig.height = 5,
             par.settings=list(fontsize=list(text=18),
                               add.line = list(col = "white"),
                               axis.line = list(col = "white"),
                               axis.text = list(col = 'white'),
                               add.text = list(col = 'white'),
                               layout.widths = list(left.padding = 3, right.padding = 0, axis.key.padding = 0)
                               ))
  })
  #str(trellis.par.get(), max.level = 1)
  ######################################################## SDI plots and Wind Roses
  output$FREQ <- renderPlot({
    req(spod_all_5min())
    req(input$spodselect)
    req(input$statselect)
    spod_all_5 <- as.data.frame(spod_all_5min())
    spod_all_5_1 <- subset(spod_all_5,
                           spod_all_5$SN == input$spodselect &
                             spod_all_5$QA == 0)
    statSDI <- input$statselectSDI
    polarFreq(spod_all_5_1, pollutant = "bc.pid.ppb",fontsize = 18,
              statistic = statSDI, main = NULL, key.position = "right")
  })
  
  SDI_build <- reactive({# SDI plot
    req(spod_all_5min())
    req(input$spodselect)
    req(input$statselect)
    spod_all_5 <- as.data.frame(spod_all_5min())
    spod_all_5_1 <- subset(spod_all_5,
                           spod_all_5$SN == input$spodselect &
                             spod_all_5$QA == 0)
    statSDI <- input$statselectSDI
    polarPlot(spod_all_5_1, pollutant = "bc.pid.ppb",  fontsize = 18,
              statistic = statSDI, main = NULL, key.position = "right")
  })
  output$SDI <- renderPlot({
    SDI_build()
  })
  WR_build <- reactive({# Wind Rose plot
    req(spod_all_5min())
    spod_all_5 <- as.data.frame(spod_all_5min())
    spod_all_5_1 <- subset(spod_all_5,
                           spod_all_5$SN == input$spodselect)
    windRose(spod_all_5_1,  fontsize = 18, paddle = F, cols = "hue",
             main = NULL, key.position = "right",
             par.settings=list(par.sub.text=list(cex=0.8)))
    
  })
  output$WR <- renderPlot({
    WR_build()
  })
  ######################################################## time series outputs
  BCplot_build <- reactive({# background Correction plot
    req(spod_all_5min())
    spod_all_5 <- as.data.frame(spod_all_5min())
    spod_all_5_1 <- subset(spod_all_5,
                           spod_all_5$SN == input$spodselect &
                             spod_all_5$QA == 0)
    p <-
      plot_ly(
        spod_all_5_1,
        x = ~ time,
        y = ~rawPID_ppb,
        type = "scatter", name = "Raw Signal",
        mode = "lines",  showlegend = T, line = list(color = "black")) %>%
      layout(showlegend = T,
             yaxis = list(title = "Signal (ppb)"),
             legend = list(
               orientation = "h",
               x = 0.3,
               y = -0.2
             ),
             xaxis = list(type = 'Date', tickformat = "%m/%d/%y")
      )
    p <- p %>% add_trace(y = spod_all_5_1$rawPID_ppb - spod_all_5_1$bc.pid.ppb, name = 'Baseline', mode = 'lines', line = list(color = "red"))
    p
  })
  
  output$BCplot <- renderPlotly({ # baseline correction plot
    BCplot_build()
  })
  
  WDplot_build <- reactive({    # Wind Direction plot
    req(spod_all_5min())
    spod_all_5 <- as.data.frame(spod_all_5min())
    spod_all_5_1 <- subset(spod_all_5,
                           spod_all_5$SN == input$spodselect &
                             spod_all_5$QA == 0)
    
    ay <- list(
      tickfont = list(color = "black"),
      overlaying = "y",
      side = "right",
      title = "Signal (ppb)")
    w <-
      plot_ly(
        spod_all_5_1,
        x = ~time,
        y = ~wd,
        type = "scatter", name = "Wind Direction",
        mode = "markers",  showlegend = T, marker = list(color = "green")) %>%
      layout(showlegend = T,
             legend = list(
               orientation = "h",
               x = 0.3,
               y = -0.2
             ),
             xaxis = list(type = 'Date', tickformat = "%m/%d/%y")
      )
    w <- w %>% add_trace(y = spod_all_5_1$bc.pid.ppb, name = 'Signal', yaxis = "y2",type = 'scatter', mode = 'lines', line = list(color = "black"), marker = list(color = 'black', opacity=0))
    w <- w %>% layout(
      yaxis2 = ay,
      xaxis = list(title="Date"),
      yaxis = list(title= list(text = "Wind Direction (Deg.)", font = list(color = 'darkgreen')), tickfont = list(color = 'darkgreen')),
      margin = list(l = 50, t = 50, b =50, r = 100, pad = 20))
    w
  })
  
  output$windplot <- renderPlotly({
    WDplot_build()
  })
  
  CTplot_build <- reactive({
    req(spod_all_5min())
    spod_all_5 <- as.data.frame(spod_all_5min())
    spod_all_5_1 <- subset(spod_all_5,
                           spod_all_5$SN == input$spodselect &
                             spod_all_5$QA == 0)
    
    spod_all_5_1$trigactiveflag <- as.character(spod_all_5_1$trigactiveflag)
    spod_all_5_1$port1 <- ifelse(grepl("1", spod_all_5_1$trigactiveflag), -1, NA)
    spod_all_5_1$port2 <- ifelse(grepl("2", spod_all_5_1$trigactiveflag), -1.4, NA)
    spod_all_5_1$port3 <- ifelse(grepl("4", spod_all_5_1$trigactiveflag), -1.8, NA)
    spod_all_5_1$port4 <- ifelse(grepl("8", spod_all_5_1$trigactiveflag), -2.2, NA)
    
    ay <- list(
      tickfont = list(color = "black"),
      overlaying = "y",
      side = "right",
      title = "Signal (ppb)")
    w <-
      plot_ly(
        spod_all_5_1,
        x = ~time,
        y = ~port1,
        type = "scatter", name = "port1",
        mode = "markers",  showlegend = T, marker = list(color = "darkgreen", size = 10, opacity = 0.8)) %>%
      layout(showlegend = T,
             yaxis = list(title = " ", range = c(-4,6), tickfont = list(color = "white"),
                          zeroline = FALSE),
             legend = list(
               orientation = "h",
               x = 0.3,
               y = -0.2
             ),
             xaxis = list(type = 'Date', tickformat = "%m/%d/%y")
      )
    w <- w %>% add_trace( spod_all_5_1,
                          x = ~time,
                          y = ~port2,
                          type = "scatter", name = "port2",
                          mode = "markers",  showlegend = T, marker = list(color = "darkcyan", size = 10, opacity = 0.8))
    w <- w %>% add_trace( spod_all_5_1,
                          x = ~time,
                          y = ~port3,
                          type = "scatter", name = "port3",
                          mode = "markers",  showlegend = T, marker = list(color = "mediumblue", size = 10, opacity = 0.8))
    w <- w %>% add_trace( spod_all_5_1,
                          x = ~time,
                          y = ~port4,
                          type = "scatter", name = "port4",
                          mode = "markers",  showlegend = T, marker = list(color = "purple4", size = 10, opacity = 0.8))
    w <- w %>% add_trace(y = spod_all_5_1$bc.pid.ppb, name = 'Signal', yaxis = "y2",type = 'scatter', mode = 'lines', line = list(color = "black"), marker = list(color = 'black', opacity=0))
    w <- w %>% layout(
      yaxis2 = ay,
      xaxis = list(title="Date"),
      yaxis = list(title="Canister Triggers"),
      margin = list(l = 50, t = 50, b =50, r = 100, pad = 20))
    
    w
  })
  
  output$canplot <- renderPlotly({ # Canister plot
    CTplot_build()
  })
  
  # v2: add WS plot
  # v2: add temp plot if data exists
  # v2: add RH plot if data exists
  
  ####################################################### Report Output Option
  output$report_button <- downloadHandler( # calls Sentinel_Report.RMD to build doc
    filename = "Sentinel_Report.pdf",
    content = function(file) {
      # render(input = "Sentinel_Report.Rmd",
      #        output_file = "Report.pdf", params = list(plotBC = BCplot_build(),
      #                                                    plotWD = WDplot_build(),
      #                                                    plotCT = CTplot_build(),
      #                                                    WR = WR_build(),
      #                                                    SDI = SDI_build(),
      #                                                    SN = input$spodselect,
      #                                                    OutputDate = Sys.Date()))
      
        tempReport <- file.path(tempdir(), "Sentinel_Report.Rmd")
        file.copy("Sentinel_Report.Rmd", tempReport, overwrite = TRUE)
        params <- list(plotBC = BCplot_build(),
                       plotWD = WDplot_build(),
                       plotCT = CTplot_build(),
                       WR = WR_build(),
                       SDI = SDI_build(),
                       SN = input$spodselect,
                       OutputDate = Sys.Date())
        rmarkdown::render(tempReport, output_file = file,
                          params = params,
                          envir = new.env(parent = globalenv())
        )
      
    }
  )
  
  #   output_dir = dirname(file),output_file = basename(file),
  
  
  
  ######################################################### SINGLE CALIBRATION PAGE
  getcaldata <- reactive({
    req(input$singlenodestarttime)
    req(input$singlenodeendtime)
    req(input$durationInput)
    req(input$file1)
    req(input$freqfile)
    duration <- as.numeric(input$durationInput)
    frequency_sec <- as.numeric(input$freqfile)
    
    start_time <- as.POSIXct(input$singlenodestarttime, tz = "America/New_York")
    end_time <- as.POSIXct(input$singlenodeendtime, tz = "America/New_York")
    
    inFile <- input$file1
    if (is.null(inFile)) {
      return(NULL)
    } else {
      numfiles = nrow(inFile)
      filelist_10 = list()
      for (i in 1:numfiles)
      {
        Data_sensit <- fread(input$file1[[i, 'datapath']], select = c(2:21), skip = 2, fill = TRUE)
        Data_sensit$timestamp <- as.POSIXct(Data_sensit$`Local Date Time`,format = "%d-%b-%Y %H:%M:%S", tz = "America/New_York")
        # Check for lat and long
        if(!'lat' %in% names(Data_sensit)) Data_sensit <- Data_sensit %>% add_column(lat = NA)
        if(!'long' %in% names(Data_sensit)) Data_sensit <- Data_sensit %>% add_column(long = NA)
        #remove baseline #######
        Data_sensit$bc_pid <- (Data_sensit$pid1_PPB_Calc - getBaseline(Data_sensit$pid1_PPB_Calc, Data_sensit$timestamp, df = 4))
        # Calc u wind and v wind
        Data_sensit$u <- Data_sensit$ws_speed * sin(2 * pi * Data_sensit$ws_direction/360)
        Data_sensit$v <- Data_sensit$ws_speed * cos(2 * pi * Data_sensit$ws_direction/360)
       
      }
    }
    filtered0 <-
      Data_sensit %>%
      filter(timestamp >= start_time &  timestamp <= end_time)
    #vectorize wind direction to avoid rounding errors between 0 and 360
    filtered0$wd <- atan2(-1 *filtered0$u, -1 *filtered0$v)*180/pi + 180
    filtered <- filtered0[,c(2,22,4:7, 25, 9:14, 16)] #change to filtered version
    #no exponent notation
    options(scipen=999)
    #fix trig flag cols
    filtered$trig.trig_value[is.na(filtered$trig.trig_value)] <- 0
    # build QA df for output file
    Mean <- lapply(filtered, mean)
    Median <- lapply(filtered, median)
    StdDev <- lapply(filtered, sd)
    Min <- lapply(filtered, min)
    Max <- lapply(filtered, max)
    N <- lapply(filtered,function(x) sum(!is.na(x)))
    DataComp <- lapply(filtered,function(x) (sum(!is.na(x))/(duration/frequency_sec))*100)
    #Round vals for table
    Mean <- round(as.numeric(Mean), 1)
    Median <- round(as.numeric(Median), 1)
    StdDev <- round(as.numeric(StdDev), 1)
    Min <- round(as.numeric(Min), 1)
    Max <- round(as.numeric(Max), 1)
    DataComp <- round(as.numeric(DataComp), 1)
    xx <- cbind(Mean, Median, StdDev, Min, Max, DataComp)
    rownames(xx) <-  c("RawPIDppb", "BCPIDppb","Tempdegc","RH", "Pressure","WS","WD","S1temp","S1Heat",
                       "S1Setarb","BatvoltV","ChargeCurrentmA","OperateCurrentmA","TrigActiveStat")
    xx
  })
  
  singlenodetimestampstart <- reactive({
    req(input$file1)
    a <- input$file1$name
    dateval <- str_match(a, "_20\\s*(.*?)\\s*.csv")
    ID <- dateval[,2]
    singlenodetimestampstart <- as.character(paste0("20", ID, " 01:00:00"))
  })
  output$singlenodestarttime <- renderUI({
    textInput(inputId = "singlenodestarttime", label = "Start Time:", value = singlenodetimestampstart())
  })
  
  singlenodetimestampend <- reactive({
    req(input$file1)
    a <- input$file1$name
    dateval <- str_match(a, "_20\\s*(.*?)\\s*.csv")
    ID <- dateval[,2]
    singlenodetimestampend <- as.character(paste0("20", ID, " 02:00:00"))
    
  })
  output$singlenodeendtime <- renderUI({
    textInput(inputId = "singlenodeendtime", label = "End Time:", value = singlenodetimestampend())
  })
  
  output$draw_caltab <- renderPlot({ # create output for app
    req(getcaldata())
    xx <- getcaldata()
    ggtexttable(xx, theme = ttheme("blank")) %>%
      tab_add_hline(at.row = 1:2, row.side = "top", linewidth = 2) %>%
      tab_add_hline(at.row = 15, row.side = "bottom", linewidth = 2)%>%
      tab_add_title(text = " ", face = "bold", padding = unit(0.2, "line"))
  })
  
  draw_caltab <- function(){ # create output for RMD
    req(getcaldata())
    req(input$singlenodestarttime)
    req(input$singlenodeendtime)
    start_time <- as.POSIXct(input$singlenodestarttime, tz = "America/New_York")
    end_time <- as.POSIXct(input$singlenodeendtime, tz = "America/New_York")
    xx <- getcaldata()
    xx <- as.data.frame(xx)
    # xx$Mean[1] = cell_spec(xx$Mean[1], color = ifelse(xx$Mean[1] < 200, "black", "red"))
    # xx$Mean[3] = cell_spec(xx$Mean[3], color = ifelse(xx$Mean[3] > -10, "black", "red"))
    # # xx$StdDev[1] = cell_spec(xx$StdDev[1], color = ifelse(xx$StdDev[1] < 20 | xx$StdDev[1] == "NA", "black", "red"))
    # # xx$StdDev[2] = cell_spec(xx$StdDev[2], color = ifelse(xx$StdDev[2] < 30 | xx$StdDev[1] == "NA", "black", "red"))
    # # xx$StdDev[3] = cell_spec(xx$StdDev[3], color = ifelse(xx$StdDev[3] > 5 | xx$StdDev[1] == "NA" , "red", "black"))
    # # xx$StdDev[4] = cell_spec(xx$StdDev[4], color = ifelse(xx$StdDev[4] > 5 | xx$StdDev[1] == "NA" , "red", "black"))
    # xx$Min[1] = cell_spec(xx$Min[1], color = ifelse(xx$Min[1] > 5 , "red", "black"))
    # xx$Min[2] = cell_spec(xx$Min[2], color = ifelse(xx$Min[2] > 10 , "red", "black"))
    # xx$Min[3] = cell_spec(xx$Min[3], color = ifelse(xx$Min[3] < -2 , "red", "black"))
    # xx$Min[4] = cell_spec(xx$Min[4], color = ifelse(xx$Min[4] < -2 , "red", "black"))
    # xx$Max[1] = cell_spec(xx$Max[1], color = ifelse(xx$Max[1] > 200 , "red", "black"))
    # xx$Max[2] = cell_spec(xx$Max[2], color = ifelse(xx$Max[2] > 400 , "red", "black"))
    # xx$Max[3] = cell_spec(xx$Max[3], color = ifelse(xx$Max[3] > 200 , "red", "black"))
    # xx$Max[4] = cell_spec(xx$Max[4], color = ifelse(xx$Max[4] > 400 , "red", "black"))
    # xx$DataComp = cell_spec(xx$DataComp, color = ifelse(xx$DataComp != 100 , "red", "black"))
    
    xx <- xx[c("Mean","Median","StdDev", "Min", "Max","DataComp")]
    xx %>%
      kbl(escape = F, caption = paste0(start_time, " to ", end_time), digits = 2, table.attr = "style='width:20%;'")%>%
      kable_classic(full_width = F, html_font = "Cambria") %>%
      kable_styling(latex_options = "HOLD_position")
  }
  
  start.end.time_1 <- function(){ # create output for RMD
    req(getcaldata())
    req(input$singlenodestarttime)
    req(input$singlenodeendtime)
    start_time <- as.POSIXct(input$singlenodestarttime, tz = "America/New_York")
    end_time <- as.POSIXct(input$singlenodeendtime, tz = "America/New_York")
    start.end.time <- paste0(substr(start_time, start = 11, stop = 23), " to",
                             substr(end_time, start = 11, stop = 23))
    start.end.time
  }
  
  SN_1 <- function(){ # create output for RMD
    req(input$file1)
    inFile <- input$file1
    if (is.null(inFile)){
      return(NULL)
    } else {
      numfiles = nrow(inFile)
      filelist_10 = list()
      for (i in 1:numfiles)
      {
        Data_sensit <- fread(input$file1[[i, 'datapath']], fill = TRUE)}}
    a <- input$file1$name[[i]]
    node <- str_match(a, "Export_\\s*(.*?)\\s*_20")
    ID <- node[,2]
    SN <- paste0("SPOD", ID)
    return(SN)
  }
  
  date_1 <- function(){ # create output for RMD
    req(input$singlenodestarttime)
    start_time <- as.POSIXct(input$singlenodestarttime, tz = "America/New_York")
    date <- paste0(substr(start_time, start = 1, stop = 10))
    date
  }
  
  QATableID_1 <- function(){ # create output for RMD
    req(input$singlenodestarttime)
    req(input$singlenodeendtime)
    start_time <- as.POSIXct(input$singlenodestarttime, tz = "America/New_York")
    end_time <- as.POSIXct(input$singlenodeendtime, tz = "America/New_York")
    start.end.time <- start.end.time_1()
    Date <- date_1()
    Serial.number <- SN_1()
    QA.table.ID <- paste0(Serial.number,"_", Date,"_", paste0(substr(start_time, start = 12, stop = 19), "-",
                                                              substr(end_time, start = 12, stop = 19)))
    # print(QA.table.ID)
    QATableID <- gsub("[[:punct:]]", "_", QA.table.ID)
    # print(QATableID)
    QATableID
  }
  
  output$singlenodereport <- downloadHandler(
    filename = "single_node_QA_Table.pdf",
    content = function(file) {
      res <- rmarkdown::render(
        "single_node_QA_Table.Rmd",
        params = list(
          draw_caltab = draw_caltab,
          SN_1 = SN_1(),
          date_1 = date_1(),
          start.end.time_1 = start.end.time_1(),
          OutputDate = Sys.Date(),
          RCodeVersion = "Version 1.0",
          QATableID_1 = QATableID_1(),
          Analyst = "_________________________________"
        )
      )
      file.rename(res, file)
    }
  )
  
  ######################################################### MULTI NODE  CALIBRATION
  
  # get cal data 1
  getcaldata1 <- reactive({
    req(input$multinodestarttime)
    req(input$multinodeendtime)
    req(input$file1multi)
    duration_sec <- as.numeric(input$durationInput2)
    frequency_sec <- as.numeric(input$freqfile2)
    
    start_time <- as.POSIXct(input$multinodestarttime, tz = "America/New_York")
    end_time <- as.POSIXct(input$multinodeendtime, tz = "America/New_York")
    inFile <- input$file1multi
    if (is.null(inFile)) {
      return(NULL)
    } else {
      numfiles = nrow(inFile)
      filelist_10 = list()
      for (i in 1:numfiles)
      {
        Data_sensit <- fread(input$file1multi[[i, 'datapath']], select = c(2:21), skip = 2, fill = TRUE)
        Data_sensit$timestamp <- as.POSIXct(Data_sensit$`Local Date Time`,format = "%d-%b-%Y %H:%M:%S", tz = "America/New_York")
        #remove baseline #######
        Data_sensit$bc_pid <- (Data_sensit$pid1_PPB_Calc - getBaseline(Data_sensit$pid1_PPB_Calc, Data_sensit$timestamp, df = 4))
        # Calc u wind and v wind
        Data_sensit$u <- Data_sensit$ws_speed * sin(2 * pi * Data_sensit$ws_direction/360)
        Data_sensit$v <- Data_sensit$ws_speed * cos(2 * pi * Data_sensit$ws_direction/360)
      }
    }
    
    filtered0 <-
      Data_sensit %>%
      filter(timestamp >= start_time &  timestamp <= end_time)
    #vectorize wind direction to avoid rounding errors between 0 and 360
    filtered0$wd <- atan2(-1 *filtered0$u, -1 *filtered0$v)*180/pi + 180
    filtered <- filtered0[,c(2,22,4:7, 25, 9:14, 16)] #change to filtered version
    #no exponent notation
    options(scipen=999)
    #fix trig flag cols
    filtered$trig.trig_value[is.na(filtered$trig.trig_value)] <- 0
    # build QA df for output file
    Mean <- lapply(filtered, mean)
    Median <- lapply(filtered, median)
    StdDev <- lapply(filtered, sd)
    Min <- lapply(filtered, min)
    Max <- lapply(filtered, max)
    N <- lapply(filtered,function(x) sum(!is.na(x)))
    DataComp <- lapply(filtered,function(x) (sum(!is.na(x))/(duration_sec/frequency_sec))*100)
    #Round vals for table
    Mean <- round(as.numeric(Mean), 1)
    Median <- round(as.numeric(Median), 1)
    StdDev <- round(as.numeric(StdDev), 1)
    Min <- round(as.numeric(Min), 1)
    Max <- round(as.numeric(Max), 1)
    DataComp <- round(as.numeric(DataComp), 1)
    xx <- cbind(Mean, Median, StdDev, Min, Max, DataComp)
    rownames(xx) <-  c("RawPIDppb", "BCPIDppb","Tempdegc","RH", "Pressure","WS","WD","S1temp","S1Heat",
                       "S1Setarb","BatvoltV","ChargeCurrentmA","OperateCurrentmA","TrigActiveStat")
    xx
  })
 
  multinodetimestampstart <- reactive({
    req(input$file1multi)
    a <- input$file1multi$name
    dateval <- str_match(a, "_20\\s*(.*?)\\s*.csv")
    ID <- dateval[,2]
    multinodetimestampstart <- as.character(paste0("20", ID, " 01:00:00"))
  })
  output$multinodestarttime <- renderUI({
    textInput(inputId = "multinodestarttime", label = "Start Time:", value = multinodetimestampstart())
  })
  
  multinodetimestampend <- reactive({
    req(input$file1multi)
    a <- input$file1multi$name
    dateval <- str_match(a, "_20\\s*(.*?)\\s*.csv")
    ID <- dateval[,2]
    multinodetimestampend <- as.character(paste0("20", ID, " 02:00:00"))
    
  })
  output$multinodeendtime <- renderUI({
    textInput(inputId = "multinodeendtime", label = "End Time:", value = multinodetimestampend())
  })
  # make table for node 2 input
  getcaldata2 <- reactive({
    req(input$multinodestarttime)
    req(input$multinodeendtime)
    req(input$file2multi)
    req(input$durationInput2) 
    req(input$freqfile2)
    duration_sec <- as.numeric(input$durationInput2)
    frequency_sec <- as.numeric(input$freqfile2)
    start_time <- as.POSIXct(input$multinodestarttime, tz = "America/New_York")
    end_time <- as.POSIXct(input$multinodeendtime, tz = "America/New_York")
    inFile <- input$file2multi
    if (is.null(inFile)) {
      return(NULL)
    } else {
      numfiles = nrow(inFile)
      filelist_10 = list()
      for (i in 1:numfiles)
      {
        Data_sensit <- fread(input$file2multi[[i, 'datapath']], select = c(2:21), skip = 2, fill = TRUE)
        Data_sensit$timestamp <- as.POSIXct(Data_sensit$`Local Date Time`,format = "%d-%b-%Y %H:%M:%S", tz = "America/New_York")
        #remove baseline #######
        Data_sensit$bc_pid <- (Data_sensit$pid1_PPB_Calc - getBaseline(Data_sensit$pid1_PPB_Calc, Data_sensit$timestamp, df = 4))
        # Calc u wind and v wind
        Data_sensit$u <- Data_sensit$ws_speed * sin(2 * pi * Data_sensit$ws_direction/360)
        Data_sensit$v <- Data_sensit$ws_speed * cos(2 * pi * Data_sensit$ws_direction/360)
      }
    }
    
    filtered0 <-
      Data_sensit %>%
      filter(timestamp >= start_time &  timestamp <= end_time)
    #vectorize wind direction to avoid rounding errors between 0 and 360
    filtered0$wd <- atan2(-1 *filtered0$u, -1 *filtered0$v)*180/pi + 180
    filtered <- filtered0[,c(2,22,4:7, 25, 9:14, 16)] #change to filtered version
    #no exponent notation
    options(scipen=999)
    #fix trig flag cols
    filtered$trig.trig_value[is.na(filtered$trig.trig_value)] <- 0
    # build QA df for output file
    Mean <- lapply(filtered, mean)
    Median <- lapply(filtered, median)
    StdDev <- lapply(filtered, sd)
    Min <- lapply(filtered, min)
    Max <- lapply(filtered, max)
    N <- lapply(filtered,function(x) sum(!is.na(x)))
    DataComp <- lapply(filtered,function(x) (sum(!is.na(x))/(duration_sec/frequency_sec))*100)
    #Round vals for table
    Mean <- round(as.numeric(Mean), 1)
    Median <- round(as.numeric(Median), 1)
    StdDev <- round(as.numeric(StdDev), 1)
    Min <- round(as.numeric(Min), 1)
    Max <- round(as.numeric(Max), 1)
    DataComp <- round(as.numeric(DataComp), 1)
    xx <- cbind(Mean, Median, StdDev, Min, Max, DataComp)
    rownames(xx) <-  c("RawPIDppb", "BCPIDppb","Tempdegc","RH", "Pressure","WS","WD","S1temp","S1Heat",
                       "S1Setarb","BatvoltV","ChargeCurrentmA","OperateCurrentmA","TrigActiveStat")
    xx
    
  })
  
  # table of sub caldata 1 - cal data 2
  output$draw_subcaltab <- renderPlot({ # create output for app
    req(getcaldata1())
    req(getcaldata2())
    xx1 <- getcaldata1()
    xx2 <- getcaldata2()
    xxsub <- round(xx1 - xx2,2)
    ggtexttable(xxsub, theme = ttheme("blank")) %>%
      tab_add_hline(at.row = 1:2, row.side = "top", linewidth = 2) %>%
      tab_add_hline(at.row = 15, row.side = "bottom", linewidth = 2)%>%
      tab_add_title(text = "Collocated QA Table", face = "bold", padding = unit(0.2, "line"))
  })
  
  draw_subcaltab <- function(){ # create output for RMD
    req(getcaldata1())
    req(getcaldata2())
    req(input$multinodestarttime)
    req(input$multinodeendtime)
    start_time <- as.POSIXct(input$multinodestarttime, tz = "America/New_York")
    end_time <- as.POSIXct(input$multinodeendtime, tz = "America/New_York")
    xx1 <- getcaldata1()
    xx2 <- getcaldata2()
    xxsub <- xx1 - xx2
    xxsub %>%
      kbl(caption = paste0(start_time, " to ", end_time), digits = 2, table.attr = "style='width:20%;'") %>%
      kable_classic(full_width = F, html_font = "Cambria") %>%
      kable_styling(latex_options = "HOLD_position")
  }
  
  start.end.time2 <- function(){ # create output for RMD
    req(getcaldata1())
    start_time <- as.POSIXct(input$multinodestarttime, tz = "America/New_York")
    end_time <- as.POSIXct(input$multinodeendtime, tz = "America/New_York")
    start.end.time <- paste0(substr(start_time, start = 11, stop = 23), " to",
                             substr(end_time, start = 11, stop = 23))
    start.end.time
  }
  
  SN1 <- function(){ # create output for RMD
    req(input$file1multi)
    inFile <- input$file1multi
    if (is.null(inFile)){
      return(NULL)
    } else {
      numfiles = nrow(inFile)
      filelist_10 = list()
      for (i in 1:numfiles)
      {
        Data_sensit <- fread(input$file1multi[[i, 'datapath']], fill = TRUE)}}
    a <- input$file1multi$name[[i]]
    node <- str_match(a, "Export_\\s*(.*?)\\s*_20")
    ID <- node[,2]
    SN <- paste0("SPOD", ID)
    return(SN)
  }
  
  SN2 <- function(){ # create output for RMD
    req(input$file2multi)
    inFile <- input$file2multi
    if (is.null(inFile)){
      return(NULL)
    } else {
      numfiles = nrow(inFile)
      filelist_10 = list()
      for (i in 1:numfiles)
      {
        Data_sensit <- fread(input$file2multi[[i, 'datapath']], fill = TRUE)}}
    a <- input$file2multi$name[[i]]
    node <- str_match(a, "Export_\\s*(.*?)\\s*_20")
    ID <- node[,2]
    SN <- paste0("SPOD", ID)
    return(SN)
  }
  
  date2 <- function(){ # create output for RMD
    start_time <- as.POSIXct(input$multinodestarttime, tz = "America/New_York")
    date <- paste0(substr(start_time, start = 1, stop = 10))
    date
  }
  
  QATableID2 <- function(){ # create output for RMD
    start_time <- as.POSIXct(input$multinodestarttime, tz = "America/New_York")
    end_time <- as.POSIXct(input$multinodeendtime, tz = "America/New_York")
    start.end.time <- start.end.time2()
    Date <- date2()
    Serial.number1 <- SN1()
    Serial.number2 <- SN2()
    QA.table.ID <- paste0(Serial.number1,Serial.number2,"_", Date,"_", paste0(substr(start_time, start = 12, stop = 19), "-",
                                                                              substr(end_time, start = 12, stop = 19)))
    QATableID <- gsub("[[:punct:]]", "_", QA.table.ID)
    QATableID
  }
  
  output$multinodereport <- downloadHandler(
    filename = "multi_node_QA_Table.pdf",
    content = function(file) {
      res <- rmarkdown::render(
        "multi_node_QA_Table.Rmd",
        params = list(
          draw_subcaltab = draw_subcaltab,
          SN1 = SN1(),
          SN2 = SN2(),
          date = date2(),
          start.end.time = start.end.time2(),
          OutputDate = Sys.Date(),
          RCodeVersion = "Version 1.2",
          QATableID = QATableID2(),
          Analyst = "_________________________________"
        )
      )
      file.rename(res, file)
    }
  )
  
  
  ######################################################### table output
  output$datatab <-  DT::renderDataTable({
    spod_all_5_tab <-  spod_all_5min()
    spod_all_5_tab <- spod_all_5_tab %>%
      mutate_if(is.numeric, round, digits = 2)
    DT::datatable(spod_all_5_tab,
                  options = list(scrollX = TRUE)) %>% formatDate(2, "toLocaleString")
  })
  
  output$Download <-
    downloadHandler(
      filename = function () {
        paste("SENTINELData.csv", sep = "")
      },
      content = function(file) {
        write.csv(spod_all_5min(), file)
      }
    )
  
  
  ######################################################### about output
  observeEvent(input$pdf, {
    file.show("SENTINEL Shiny App User Guide V1.pdf")
  })
  observeEvent(input$SOP, {
    file.show("J-AMCD-SFSB-SOP-4380-2_Sensit SPod SOP.pdf")
  })
  
  
  
  
  
}


shinyApp(ui, server)


